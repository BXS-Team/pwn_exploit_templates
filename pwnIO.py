from pwn import *
import copy
libc_version = ["2.23", "2.27", "2.29"]
linux_arch = ["i386", "amd64"]

class pwnIO():
    def __init__(self, filename,  libcv,ip="", port=0, is_remote=False,is_debug=True,libc_path=None, timeout=None,token="",gdbscript=""):
        self.binary_name = filename
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.token = token
        self.gdbscript=gdbscript
        context.os = 'linux'
        assert(libcv in libc_version)
        if libc_path!=None:
            self.libc_path="/ctf/work/"
            if libcv=='2.27':
                self.libc_path+="glibc-2.27/malloc/"
            elif libcv=='2.23':
                self.libc_path+="glibc-2.23/malloc/"
            else:
                self.libc_path+="glibc-2.29/malloc/"
        if is_remote:
            self.io=remote(ip,port)
            self.elf=ELF(filename)
            self.libc=self.elf.libc
        else:
            self.io=process(self.binary_name)
            self.libc=self.io.libc
            self.elf=self.io.elf
        if is_debug:
            context.log_level="debug"
            context.terminal = ['tmux', 'sp', '-h', '-l', '110']
        else:
            context.log_level="info"
        context.arch=self.elf.arch



    def set_token(self, token):
        self.token = token
        log.info("token: %s" % (token))

    def send_token(self):
        self.sl(self.token)
        log.info("send token: %s" % (self.token))

    def close_io(self):
        if self.is_debug:
            self.io.kill()
        else:
            self.io.close()
        self.is_debug = None

    def attach(self, gdbscript=None):
        if self.is_remote:
            log.failure("remoting")
            return None
        if gdbscript:
            gdbscript+='\n'
        gdbscript+="directory "%self.libc_path
        return gdb.attach(self.io, gdbscript)

    def s(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.send(str(data))
        else:
            return self.io.send(data)

    def sl(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.sendline(str(data))
        else:
            return self.io.sendline(data)

    def sla(self, delim, data, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.sendlineafter(delim, str(data), timeout)

    def r(self, numb=4096, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recv(numb, timeout)

    def ru(self, delims, drop=True, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvuntil(delims, drop=drop, timeout=timeout)

    def ra(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvall(timeout=timeout)

    def rl(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvline(timeout=timeout)

    def it(self, prompt='\x1b[1m\x1b[31m$\x1b[m '):
        assert(self.io is not None)
        return self.io.interactive(prompt)
        """
        interactive(prompt = pwnlib.term.text.bold_red('$') + ' ')
        """

    def recvline(self, timeout=pwnlib.timeout.Timeout.default):
        store_buf = ''
        while True:
            buf = self.r(1, timeout=timeout)
            if buf == '' or buf == '\n':
                return store_buf
            else:
                store_buf += buf

    # def attach(self, gdbscript=None, exe=None, need_ptrace_scope=True, gdb_args=None, ssh=None, sysroot=None):
    #     if not self.is_debug:
    #         log.failure("remoting")
    #         return None
    #     else:
    #         if gdbscript is None:
    #             gdbscript = "directory %s" %(self.libc_path)
    #         else:
    #             gdbscript += "\ndirectory %s" %(self.libc_path)
    #         return gdb.attach(self.io, gdbscript=gdbscript, exe=exe, need_ptrace_scope=need_ptrace_scope, gdb_args=gdb_args, ssh=ssh, sysroot=sysroot)

    class func():
        def __init__(self, obj, name, choice, timeout):
            """
            pretends that it is a menu
            args{ idx size cont }
            """
            self.func_name = name
            self.io = obj
            self.timeout = timeout
            self.choice = choice
            self.conditions=[]
            self.condition_names=[]
            self.condition_results[]
            self.add_conditions('is_not_r','sleep','send')

        def add_conditions(self,*condition_names):
            condition_names=list(condition_names)
            for condition_name in condition_names:
                self.condition_names.append(condition_name)
                self.conditions.append(dict())
                self.condition_results.append(None)
        def set_condition(self,condition_name,condition_index_value):
            if type(condition_index_value)==list:
                condition_index_value_dict=zip(condition_index_value,list(list() for i in range(len(condition_index_value))))
            elif type(condition_index_value)==dict:
                for key,values in condition_index_value.items():
                    if not type(values)==list:
                        condition_index_value[key]=[values]
                condition_index_value_dict=condition_index_value
            else:
                print("--------------------------------")
                print("condition_index_value type error")
                print("--------------------------------")
                exit()
            self.conditions[self.condition_names.index(condition_name)].update(condition_index_value_dict)

        def recvline(self):
            buf = '\n'
            while buf != b'':
                buf = self.io.r(timeout=self.timeout)
                if not buf.endswith(b'\n'):
                    return

        def x(self, *args):
            args = list(args)
            args.insert(0, self.choice)
            is_send=False
            is_recv=True
            for i in range(len(args)):
                arg = args[i]
                # if isinstance(arg, int):
                #     self.io.sl(arg)
                # else:
                #     self.io.s(arg)
                # if condition != 0:
                #     if condition == 'sleep':
                #         sleep(self.conditions_value[i])
                for condition in self.conditions:
                    if i in condition.keys():
                        condition_value=condition.get(i)
                        condition_index=self.conditions.index(condition)
                        condition_name =self.condition_names[condition_index]
                        if condition_name=="send":
                            is_send=True
                        elif condition_name=="is_not_r":
                            is_recv=False
                        else:
                            condition_results[condition_index]=eval(condition_name)(*condition_value)
                    if condition==self.condition[0]:
                        if is_recv:
                            condition_results[0]=self.io.r(timeout=0.01)
                        else:
                            is_recv=True
                if isinstance(arg, int):
                     self.io.sl(arg)
                elif is_send:
                    self.io.s(arg)
                else:
                    self.io.sl(arg)
        def __call__(self, *args):
            self.x(*args)

    def add_func(self, name, choice=None, timeout=None):
        if timeout is None:
            to = self.timeout
        else:
            to = timeout
        if name=="add":
            choice=1
        elif name=="rm":#remove
            choice=2
        elif name=="ed":#edit
            choice=3
        elif name=="sw":#show
            choice=4
        else:
            print("--------------")
            print("not support %s function deault choice"%name)
        func = self.func(self, name, choice, timeout=to)
        return func
"""
add = io.add_func('add')
add(1, 2, 3, 4)
"""
def b(self, string=None):
    input(string)

def uu64(data):
    num = u64(data.ljust(8, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu32(data):
    num = u32(data.ljust(4, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu16(data):
    num = u16(data.ljust(2, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu8(data):
    num = u8(data.ljust(1, b'\x00'))
    log.success("%#x" %(num))
    return num