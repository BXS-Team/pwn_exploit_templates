from pwn import *
import copy
import subprocess
import os
linux_arch = ["i386", "amd64"]

class pwnIO():
    def __init__(self, filename,  libcv,ip="", port=0, is_remote=False,is_debug=True,full_path="",libc_source_path=None, timeout=None,token="",gdbscript=""):
        self.filename = filename
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.token = token
        self.gdbscript=gdbscript
        self.is_remote=is_remote
        context.os = 'linux'
        if full_path=="":
            self.full_path=os.getcwd()+'/'
        self.command='ncat -vc  /ctf/work/%s -l 0.0.0.0 20000'%(self.filename)
        if libcv=='2.27':
            self.system_version="18.04"
        elif libcv=='2.23':
            self.system_version="16.04"
        elif libcv=="2.29":
            self.system_version="19.04"
        elif libcv=="2.30":
            self.system_version="19.10"
        else :
            self.system_version="host"
            self.libc_path="/usr/lib/libc.so.6"
        if is_remote:
            self.io=remote(ip,port)
            self.elf=ELF(filename)
            self.libc=self.elf.libc
        else:
            if self.system_version=="host":
                self.io=process(self.full_path+self.filename)
                self.libc=self.io.libc
                self.elf=self.io.elf
            else:
                docker_stdout = open("docker_stdout", 'w')
                docker_stderr = open("docker_stderr",'w')
                docker_stdin = open("docker_stdin",'r')
                try:
                    self.docker_proc=subprocess.Popen("docker run -p 20000:20000 -v  %s:/ctf/work/ ubuntu:%s %s"%(self.full_path,self.system_version,self.command),stdout=docker_stdout, stderr=docker_stderr,shell=True)
                except:
                    print("--------")
                    print("docker setup error")
                    print('--------')
                    self.docker_proc.kill()
                    exit()
                self.docker_proc.stdin=docker_stdin
                sleep(0.2)
                self.io=remote('127.0.0.1',20000)
        if is_debug:
            context.log_level="debug"
        else:
            context.log_level="info"



    def set_token(self, token):
        self.token = token
        log.info("token: %s" % (token))

    def send_token(self):
        self.sl(self.token)
        log.info("send token: %s" % (self.token))

    def close_io(self):
        if self.is_debug:
            self.io.kill()
        else:
            self.io.close()
        self.is_debug = None

    def attach(self, gdbscript=None):
        if self.is_remote:
            log.failure("remoting")
            return None
        else:
            if self.system_version=="host":
                gdb.attach(io)
            else:
                pid = os.fork()

                if pid == 0:
        # Closing the file descriptors makes everything fail under tmux on OSX.
                    proc_pid=os.popen("pidof %s"%self.filename).read()
                    devnull = open(os.devnull, 'r+b')
                    os.dup2(devnull.fileno(), 0)
                    os.dup2(devnull.fileno(), 1)
                    os.dup2(devnull.fileno(), 2)
                    os.execv("/usr/bin/konsole",("konsole -e sudo gdb attach %d"%int(proc_pid)).split(' '))
                    os._exit(1)
    def s(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.send(str(data))
        else:
            return self.io.send(data)

    def sl(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.sendline(str(data))
        else:
            return self.io.sendline(data)

    def sla(self, delim, data, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.sendlineafter(delim, str(data), timeout)

    def r(self, numb=4096, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recv(numb, timeout)

    def ru(self, delims, drop=True, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvuntil(delims, drop=drop, timeout=timeout)

    def ra(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvall(timeout=timeout)

    def rl(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvline(timeout=timeout)

    def it(self, prompt='\x1b[1m\x1b[31m$\x1b[m '):
        assert(self.io is not None)
        return self.io.interactive(prompt)
        """
        interactive(prompt = pwnlib.term.text.bold_red('$') + ' ')
        """

    def recvline(self, timeout=pwnlib.timeout.Timeout.default):
        store_buf = ''
        while True:
            buf = self.r(1, timeout=timeout)
            if buf == '' or buf == '\n':
                return store_buf
            else:
                store_buf += buf

    # def attach(self, gdbscript=None, exe=None, need_ptrace_scope=True, gdb_args=None, ssh=None, sysroot=None):
    #     if not self.is_debug:
    #         log.failure("remoting")
    #         return None
    #     else:
    #         if gdbscript is None:
    #             gdbscript = "directory %s" %(self.libc_path)
    #         else:
    #             gdbscript += "\ndirectory %s" %(self.libc_path)
    #         return gdb.attach(self.io, gdbscript=gdbscript, exe=exe, need_ptrace_scope=need_ptrace_scope, gdb_args=gdb_args, ssh=ssh, sysroot=sysroot)

    class func():
        def __init__(self, obj, name, choice, timeout):
            """
            pretends that it is a menu
            args{ idx size cont }
            """
            self.func_name = name
            self.io = obj
            self.timeout = timeout
            self.choice = choice
            self.conditions=[]
            self.condition_names=[]
            self.condition_results=[]
            self.add_conditions('is_not_r','sleep','send')

        def add_conditions(self,*condition_names):
            condition_names=list(condition_names)
            for condition_name in condition_names:
                self.condition_names.append(condition_name)
                self.conditions.append(dict())
                self.condition_results.append(None)
        def set_condition(self,condition_name,condition_index_value):
            if type(condition_index_value)==list:
                condition_index_value_dict=zip(condition_index_value,list(list() for i in range(len(condition_index_value))))
            elif type(condition_index_value)==dict:
                for key,values in condition_index_value.items():
                    if not type(values)==list:
                        condition_index_value[key]=[values]
                condition_index_value_dict=condition_index_value
            else:
                print("--------------------------------")
                print("condition_index_value type error")
                print("--------------------------------")
                exit()
            self.conditions[self.condition_names.index(condition_name)].update(condition_index_value_dict)

        def recvline(self):
            buf = '\n'
            while buf != b'':
                buf = self.io.r(timeout=self.timeout)
                if not buf.endswith(b'\n'):
                    return

        def x(self, *args):
            args = list(args)
            args.insert(0, self.choice)
            is_send=False
            is_recv=True
            for i in range(len(args)):
                arg = args[i]
                # if isinstance(arg, int):
                #     self.io.sl(arg)
                # else:
                #     self.io.s(arg)
                # if condition != 0:
                #     if condition == 'sleep':
                #         sleep(self.conditions_value[i])
                for condition in self.conditions:
                    if i in condition.keys():
                        condition_value=condition.get(i)
                        condition_index=self.conditions.index(condition)
                        condition_name =self.condition_names[condition_index]
                        if condition_name=="send":
                            is_send=True
                        elif condition_name=="is_not_r":
                            is_recv=False
                        else:
                            condition_results[condition_index]=eval(condition_name)(*condition_value)
                    if condition==self.condition[0]:
                        if is_recv:
                            condition_results[0]=self.io.r(timeout=0.01)
                        else:
                            is_recv=True
                if isinstance(arg, int):
                     self.io.sl(arg)
                elif is_send:
                    self.io.s(arg)
                else:
                    self.io.sl(arg)
        def __call__(self, *args):
            self.x(*args)

    def add_func(self, name, choice=None, timeout=None):
        if timeout is None:
            to = self.timeout
        else:
            to = timeout
        if name=="add":
            choice=1
        elif name=="rm":#remove
            choice=2
        elif name=="ed":#edit
            choice=3
        elif name=="sw":#show
            choice=4
        else:
            print("--------------")
            print("not support %s function deault choice"%name)
        func = self.func(self, name, choice, timeout=to)
        return func
"""
add = io.add_func('add')
add(1, 2, 3, 4)
"""
def b(string=None):
    input(string)

def uu64(data):
    num = u64(data.ljust(8, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu32(data):
    num = u32(data.ljust(4, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu16(data):
    num = u16(data.ljust(2, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu8(data):
    num = u8(data.ljust(1, b'\x00'))
    log.success("%#x" %(num))
    return num