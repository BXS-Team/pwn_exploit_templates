from pwn import *
import copy
import subprocess
import os
linux_arch = ["i386", "amd64"]
choice_flag='>'
context_flag=':'
class pwnIO():
    def __init__(self, filename,  libcv,ip="", port=0, is_remote=False,is_debug=True,full_path="",libc_source_path=None, timeout=None,token="",gdbscript=""):
        self.filename = filename
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.token = token
        self.gdbscript=gdbscript
        self.is_remote=is_remote
        context.os = 'linux'
        if full_path=="":
            self.full_path=os.getcwd()+'/'
        self.command='/bin/bash -c "cd /ctf/work&&/ctf/work/static_binary/ncat -vc  /ctf/work/%s -l 0.0.0.0 20000"'%(self.filename)
        if libcv=='2.27':
            self.system_version="18.04"
        elif libcv=='2.23':
            self.system_version="16.04"
        elif libcv=="2.29":
            self.system_version="19.04"
        elif libcv=="2.30":
            self.system_version="19.10"
        else :
            self.system_version="host"
            self.libc_path="/usr/lib/libc.so.6"
        if is_remote:
            self.io=remote(ip,port)
            self.elf=ELF(filename)
            self.libc=self.elf.libc
        else:
            if self.system_version=="host":
                self.io=process(self.full_path+self.filename)
                self.libc=self.io.libc
                self.elf=self.io.elf
            else:
                self.docker_stdout = open("docker_stdout", 'r+')
                self.docker_stderr = open("docker_stderr",'r+')
                self.docker_stdin = open("docker_stdin",'r+')
                try:
                    self.docker_proc=subprocess.Popen("docker run --rm -p 20000:20000 -v  %s:/ctf/work/ ubuntu:%s %s"%(self.full_path,self.system_version,self.command),stdout=self.docker_stdout, stderr=self.docker_stderr,shell=True)
                except:
                    print("--------")
                    print("docker setup error")
                    print('--------')
                    exit()
                sleep(0.2)
                self.docker_log()
                self.docker_proc.stdin=self.docker_stdin
                connect_conut=10
                while True:
                    try:
                        self.io=remote('127.0.0.1',20000)
                    except:
                        self.io.close()
                        connect_conut-=1
                        if connect_conut:
                            continue
                        else:
                            print('------------')
                            print('connect fail')
                            print('------------')
                            exit(0)
                    break
                pid=[]
                # wait docker
                while True:
                    pid=list(pidof(self.filename))
                    if pid:
                        break
                    sleep(0.1)
        if is_debug:
            context.log_level="debug"
        else:
            context.log_level="info"


    def docker_log(self):
        print('-------------')
        print('docker log')
        print("docker_stdout")
        self.docker_stdout.seek(0)
        lines=self.docker_stdout.readlines()
        for line in lines:
            print(line,end='')
        print('docker_stderr')
        self.docker_stderr.seek(0)
        lines=self.docker_stderr.readlines()
        for line in lines:
            print(line,end='')
        print("docker end")
        print('--------------')
    def set_token(self, token):
        self.token = token
        log.info("token: %s" % (token))

    def send_token(self):
        self.sl(self.token)
        log.info("send token: %s" % (self.token))

    def close_io(self):
        if self.is_debug:
            self.io.kill()
        else:
            self.io.close()
        self.is_debug = None

    def attach(self, gdbscript=None):
        if self.is_remote:
            log.failure("remoting")
            return None
        else:
            if self.system_version=="host":
                gdb.attach(self.io)
            else:
                gdb.attach(target=self.filename,exe=self.filename)
        #         pid = os.fork()

        #         if pid == 0:
        # # Closing the file descriptors makes everything fail under tmux on OSX.
        #             devnull = open(os.devnull, 'r+b')
        #             os.dup2(devnull.fileno(), 0)
        #             os.dup2(devnull.fileno(), 1)
        #             os.dup2(devnull.fileno(), 2)
        #             os.execv("/usr/bin/konsole",("konsole -e gdb attach %d"%int(proc_pid)).split(' '))
        #             os._exit(1)
    def s(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.send(str(data))
        else:
            return self.io.send(data)

    def sl(self, data):
        assert(self.io is not None)
        if isinstance(data, int):
            return self.io.sendline(str(data))
        else:
            return self.io.sendline(data)

    def sla(self, delim, data, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        if isinstance(data,bytes):
            return self.io.sendlineafter(delim, data, timeout)
        else:
            return self.io.sendlineafter(delim, data, timeout)
    def sa(self, delim, data, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        if isinstance(data,bytes):
            return self.io.sendafter(delim, data, timeout)
        else:
            return self.io.sendafter(delim, str(data), timeout)
    def r(self, numb=4096, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recv(numb, timeout)

    def ru(self, delims, drop=True, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvuntil(delims, drop=drop, timeout=timeout)

    def ra(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvall(timeout=timeout)

    def rl(self, timeout=pwnlib.timeout.Timeout.default):
        assert(self.io is not None)
        return self.io.recvline(timeout=timeout)

    def it(self, prompt='\x1b[1m\x1b[31m$\x1b[m '):
        assert(self.io is not None)
        return self.io.interactive(prompt)
        """
        interactive(prompt = pwnlib.term.text.bold_red('$') + ' ')
        """

    def recvline(self, timeout=pwnlib.timeout.Timeout.default):
        store_buf = ''
        while True:
            buf = self.r(1, timeout=timeout)
            if buf == '' or buf == '\n':
                return store_buf
            else:
                store_buf += buf

    # def attach(self, gdbscript=None, exe=None, need_ptrace_scope=True, gdb_args=None, ssh=None, sysroot=None):
    #     if not self.is_debug:
    #         log.failure("remoting")
    #         return None
    #     else:
    #         if gdbscript is None:
    #             gdbscript = "directory %s" %(self.libc_path)
    #         else:
    #             gdbscript += "\ndirectory %s" %(self.libc_path)
    #         return gdb.attach(self.io, gdbscript=gdbscript, exe=exe, need_ptrace_scope=need_ptrace_scope, gdb_args=gdb_args, ssh=ssh, sysroot=sysroot)

    class func():
        def __init__(self, obj, choice, timeout):
            """
            pretends that it is a menu
            args{ idx size cont }
            """
            self.io = obj
            self.timeout = timeout
            self.choice = choice
            self.conditions=[]
            self.condition_names=[]
            self.condition_results=[]
            self.add_conditions('sleep')

        def add_conditions(self,*condition_names):
            condition_names=list(condition_names)
            for condition_name in condition_names:
                self.condition_names.append(condition_name)
                self.conditions.append(dict())
                self.condition_results.append(None)
        def set_condition(self,condition_name,condition_index_value):
            if type(condition_index_value)==list:
                condition_index_value_dict=zip(condition_index_value,list(list() for i in range(len(condition_index_value))))
            elif type(condition_index_value)==dict:
                for key,values in condition_index_value.items():
                    if not type(values)==list:
                        condition_index_value[key]=[values]
                condition_index_value_dict=condition_index_value
            else:
                print("--------------------------------")
                print("condition_index_value type error")
                print("--------------------------------")
                exit()
            self.conditions[self.condition_names.index(condition_name)].update(condition_index_value_dict)

        def recvline(self):
            buf = '\n'
            while buf != b'':
                buf = self.io.r(timeout=self.timeout)
                if not buf.endswith(b'\n'):
                    return

        def x(self, *args):
            args = list(args)
            self.io.sla(choice_flag,self.choice)
            for i in range(len(args)):
                arg = args[i]
                # if isinstance(arg, int):
                #     self.io.sl(arg)
                # else:
                #     self.io.s(arg)
                # if condition != 0:
                #     if condition == 'sleep':
                #         sleep(self.conditions_value[i])
                for condition in self.conditions:
                    if i in condition.keys():
                        condition_value=condition.get(i)
                        condition_index=self.conditions.index(condition)
                        condition_name =self.condition_names[condition_index]
                        self.condition_results[condition_index]=eval(condition_name)(*condition_value)
                if isinstance(arg, int):
                     self.io.sla(context_flag,arg)
                else:
                    self.io.sa(context_flag,arg)
        def __call__(self, *args):
            self.x(*args)
    def add_func(self,choice, timeout=None):
        if timeout is None:
            to = self.timeout
        else:
            to = timeout
        func = self.func(self, choice, timeout=to)
        return func

def b(string=None):
    input(string)

def uu64(data):
    num = u64(data.ljust(8, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu32(data):
    num = u32(data.ljust(4, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu16(data):
    num = u16(data.ljust(2, b'\x00'))
    log.success("%#x" %(num))
    return num

def uu8(data):
    num = u8(data.ljust(1, b'\x00'))
    log.success("%#x" %(num))
    return num
def get_addr(data):
    num=int.from_bytes(data, byteorder='little', signed=False)
    return num
